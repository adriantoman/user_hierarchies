#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end
$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + '/../lib')
require 'rubygems'
require 'gli'
require 'pp'
include GLI

program_desc 'User hierarchies - a little util to help you deal with user hierarchies'
version Es::VERSION

desc 'Password'
arg_name 'password'
flag [:p, :password]

desc 'Login'
arg_name 'login'
flag [:l, :login]


desc 'Jack into SalesForce project'
command :jack_in do |c|
  c.action do |global_options,options,args|
    GoodData::UserHierarchies::UserHierarchy.load_users_from_sf(options[:login], options[:password]) do |hierarchy|
      binding.pry
    end
    
  end
end

pre do |global,command,options,args|
  # next true if command.nil?
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  # fail "PID env variable should be specified" if PID.nil? || PID.empty?
  # fail "ES_NAME env variable should be specified" if ES_NAME.nil? || ES_NAME.empty?
  # fail "LOGIN env variable should be specified" if LOGIN.nil? || LOGIN.empty?
  # fail "PASSWORD env variable should be specified" if PASSWORD.nil? || PASSWORD.empty?

  # GoodData.logger = Logger.new(STDOUT) if global[:logger]
  # GD_SERVER = global[:server]
  # GD_WEBDAV = global[:webdav]
  # begin
  #   GoodData.connect LOGIN, PASSWORD, GD_SERVER, {
  #     :timeout       => 60,
  #     :webdav_server => GD_WEBDAV
  #   }
  # rescue RestClient::BadRequest => e
  #   puts "Login Failed"
  #   exit 1
  # end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
   pp exception.backtrace
  if exception.is_a?(SystemExit) && exception.status == 0
    false
  else
    # pp exception.inspect
    puts exception.message.color(:red)
    false
  end
  
  # Error logic here
  # return false to skip default error handling
  # false
  # true
end

exit GLI.run(ARGV)

